# -*- coding: utf-8 -*-
"""cuckoo_search_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C467VRLOgW5j0d_H4JmBWzNFtCRdgShg
"""

import numpy as np
import random
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.table as tbl

# Constants
NTS = 20  # Number of tasks
NVM = 4   # Number of virtual machines
Max_Generation = 200
pa = 0.25  # Probability of abandoning worst nests

#Example task execution times
# task_execution_times = np.array([
#    [9, 11, 10],
#     [11, 7, 9],
#     [8, 7, 6],
#     [9, 17, 10],
#     [12, 15, 9],
#     [17, 12, 14],
#     [16, 12, 11],
#    [8, 15, 10],
#     [11, 8, 6],
#     [10, 12, 14]
# ])


#When VM = 4
# task_execution_times = np.array([
#     [9, 11, 10, 12],
#     [11, 7, 9, 13],
#     [8, 7, 6, 14],
#     [9, 17, 10, 11],
#     [12, 15, 9, 10],
#     [17, 12, 14, 8],
#     [16, 12, 11, 9],
#     [8, 15, 10, 12],
#     [11, 8, 6, 15],
#     [10, 12, 14, 10]
# ])


task_execution_times = np.array([
    [9, 11, 10, 12],
    [11, 7, 9, 13],
    [8, 7, 6, 14],
    [9, 17, 10, 11],
    [12, 15, 9, 10],
    [17, 12, 14, 8],
    [16, 12, 11, 9],
    [8, 15, 10, 12],
    [11, 8, 6, 15],
    [10, 12, 14, 10],
    [14, 16, 10, 9],
    [10, 11, 8, 13],
    [13, 7, 9, 14],
    [12, 8, 10, 11],
    [15, 12, 9, 10],
    [16, 14, 11, 13],
    [9, 12, 10, 8],
    [11, 10, 12, 9],
    [14, 9, 11, 12],
    [10, 15, 13, 11]
])


# Algorithm 1: To find the schedule length
def schedule_length(schedule):
    Re_Time = np.zeros(NVM)
    St_Time = np.zeros((NTS, NVM))
    Ft_Time = np.zeros((NTS, NVM))

    for task in range(NTS):
        vm = int(schedule[task])  # Ensure vm is an integer
        if vm >= NVM:
            raise ValueError(f"VM index {vm} out of bounds for available VMs")
        St_Time[task, vm] = max(Re_Time[vm], 0)  # Assuming Da_Arriv(TSi, VMj) = 0 for simplicity
        Ft_Time[task, vm] = St_Time[task, vm] + task_execution_times[task, vm]
        Re_Time[vm] = Ft_Time[task, vm]

    return np.max(Ft_Time), St_Time, Ft_Time


# Algorithm 2: Cuckoo Search via Levy Flights
def levy_flight(Lambda):
    sigma_u = np.power((np.math.gamma(1 + Lambda) * np.sin(np.pi * Lambda / 2)) /
                       (np.math.gamma((1 + Lambda) / 2) * Lambda * np.power(2, (Lambda - 1) / 2)), 1 / Lambda)
    sigma_v = 1
    u = np.random.normal(0, sigma_u, size=1)
    v = np.random.normal(0, sigma_v, size=1)
    step = u / np.power(np.abs(v), 1 / Lambda)
    return step

# Algorithm 3: The function that converts a continuous value to a discrete value
def converting(s):
    Ran = random.randint(1, 5)
    if Ran == 1:
        return [k % NVM for k in sorted(range(len(s)), key=lambda k: s[k] % NVM)]
    elif Ran == 2:
        return [k % NVM for k in sorted(range(len(s)), key=lambda k: s[k] % NVM, reverse=True)]
    elif Ran == 3:
        return [round(val) % NVM for val in s]
    elif Ran == 4:
        return [int(np.floor(val) % NVM) for val in s]
    else:
        return [int(np.ceil(val) % NVM) for val in s]


# Algorithm 4: ECS (Cuckoo Search with Embedded Task Scheduling)
def ECS(DAG, Max_Generation):
    # Initialization
    n = 20  # Number of nests
    nests = [np.random.randint(0, NVM, size=NTS) for _ in range(n)]  # Generate initial nests within bounds
    fitness = [schedule_length(nest)[0] for nest in nests]

    best_nest = nests[np.argmin(fitness)]
    best_fitness = min(fitness)

    for gen in range(Max_Generation):
        # Levy flight and random selection
        for i in range(n):
            step_size = levy_flight(1.5)
            new_nest = nests[i] + step_size * np.random.randn(NTS)
            new_nest = np.clip(new_nest, 0, NVM - 1)  # Clip values to ensure they are within bounds
            # Convert new_nest from continuous to discrete
            discrete_new_nest = converting(new_nest)

            new_fitness = schedule_length(discrete_new_nest)[0]

            if new_fitness < fitness[i]:
                nests[i] = discrete_new_nest
                fitness[i] = new_fitness

                if new_fitness < best_fitness:
                    best_fitness = new_fitness
                    best_nest = discrete_new_nest

        # Abandonment and new solutions
        for i in range(n):
            if random.random() < pa:
                nests[i] = np.random.randint(0, NVM, size=NTS)  # Generate a new random nest within bounds
                fitness[i] = schedule_length(nests[i])[0]

        best_fitness = min(fitness)
        best_nest = nests[np.argmin(fitness)]

    return best_nest, best_fitness


# Calculate speedup, efficiency, and throughput
def calculate_metrics(schedule, Ft_Time):
    schedule_length = np.max(Ft_Time)

    total_execution_time = np.zeros(NVM)
    for task in range(NTS):
        vm = int(schedule[task])  # Ensure vm is an integer
        if vm >= NVM:
            raise ValueError(f"VM index {vm} out of bounds for available VMs")
        total_execution_time[vm] += task_execution_times[task, vm]

    speedup = np.min(total_execution_time) / schedule_length
    efficiency = speedup / NVM
    throughput = NTS / schedule_length

    return speedup, efficiency, throughput


# Example usage
DAG = None  # The DAG structure should be defined as per specific problem requirements
best_schedule, best_fitness = ECS(DAG, Max_Generation)
schedule_length_value, St_Time, Ft_Time = schedule_length(best_schedule)

# Calculate the metrics
speedup, efficiency, throughput = calculate_metrics(best_schedule, Ft_Time)

print(f"Best schedule: {best_schedule}")
print(f"Schedule length (Makespan): {schedule_length_value}")
print(f"Speedup: {speedup}")
print(f"Efficiency: {efficiency}")
print(f"Throughput: {throughput}")

# Prepare the schedule table
schedule_table = []

for task in range(NTS):
    row = ['TS' + str(task)]
    for vm in range(NVM):
        if St_Time[task, vm] > 0 or Ft_Time[task, vm] > 0:
            row.append(f"({int(St_Time[task, vm])}, {int(Ft_Time[task, vm])})")
        else:
            row.append('-')
    schedule_table.append(row)

# Convert to DataFrame for better visualization
df = pd.DataFrame(schedule_table, columns=['Task'] + [f'VM{i+1}' for i in range(NVM)])
print(df)

# Plot the table
fig, ax = plt.subplots(figsize=(10, 4))
ax.axis('tight')
ax.axis('off')
table = tbl.table(ax, cellText=df.values, colLabels=df.columns, cellLoc = 'center', loc='center')
table.auto_set_font_size(False)
table.set_fontsize(10)
table.scale(1.2, 1.2)
plt.show()